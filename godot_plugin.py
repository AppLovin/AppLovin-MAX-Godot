#!/usr/bin/python
#
#  Python script used for developing, building, and managing the Godot plugin and environment
#
#  Created by Christopher Cong on 12/02/24.
#
#  Usage: python godot_plugin.py <command> [arguments]
#

import glob
import os
import sys
import tarfile
import shutil
import subprocess
try:
    # Python 3
    from urllib.request import urlretrieve
except ImportError:
    # Python 2
    from urllib import urlretrieve

def show_help():
    help_text = """
Godot Build Script
-------------------
Usage: python godot_plugin.py <command> [arguments]

Commands:
  Main Commands:
    prepare_plugin_environment <VERSION>        Set up the environment for plugin development (downloads Godot and Android libraries, generates iOS headers).
    build_ios --version=<VERSION> [--debug]     Build the iOS plugin.
    build_android --version=<VERSION> [--debug] Build the Android plugin.
    clean                                       Remove artifacts generated by previous builds or downloads.

  Plugin Development Commands:
    download_godot <VERSION>              Download and extract the specified Godot version.
    download_android_lib <VERSION>        Download the Godot Android library.
    generate_ios_headers                  Generate iOS headers using SCons.

Options:
  -h, --help                     Show this help message and exit.

Examples:
  python godot_plugin.py clean
  python godot_plugin.py prepare_ios_plugin 4.3
  python godot_plugin.py build_ios --version=1.1.0

Description:
  This script automates the build process for Godot projects, including downloading specific versions,
  generating iOS headers, and performing clean and build. It combines common tasks into a single utility.

Report issues or contribute to the script on this repository.
"""
    print(help_text)

### Main Commands ###

# Prepare the environment for plugin development and building. Downloads the Godot engine, Godot Android library, and generates the iOS headers.
def prepare_plugin_environment(version):
    if not version:
        print("Error: Please provide the Godot version as an argument.")
        sys.exit(1)

    try:
        print("Preparing plugin environment...")
        
        clean()
        
        download_godot(version)

        download_godot_android_lib(version)
        
        generate_ios_headers()

        generate_pods()

        print("Plugin environment prepared successfully.")

    except subprocess.CalledProcessError as e:
        print("Prepare iOS plugin failed: {}".format(e))

# Build the iOS plugin in either debug or release target.
def build_ios(version=None, debug=False):
    try:
        target = "Debug" if debug else "Release"
        print("Building iOS plugin in {} target...".format(target))

        build_dir = "./Source/iOS/build"
        generate_xcframework(target, version, build_dir)

        # Move the xcframework to the plugin directory
        plugin_name = "AppLovin-MAX-Godot-Plugin.xcframework"
        xcframework = "AppLovin-MAX-Godot-Plugin.{}.xcframework".format(target)
        xcframework_path = "{}/{}".format(build_dir, xcframework)
        rename(xcframework_path, plugin_name)
        move(build_dir + "/" + plugin_name, "ios/plugins/AppLovin-MAX-Godot-Plugin/")

        for file in os.listdir(build_dir):
            if file.endswith(".xcarchive"):
                print("Removing ios build artifact: {}...".format(file))
                os.remove(file)

        print("iOS plugin build in {} target completed successfully.".format(target))
    except Exception as e:
        print("Error during iOS plugin {} build: {}".format(target), e)

# Build the Android plugin in either debug or release target.
def build_android(version=None, debug=False):
    try:
        target = "Debug" if debug else "Release"
        gradle_task = "assemble{}".format(target)

        if version:
            build_gradle_path = "Source/Android/build.gradle.kts"

            print("Updating version in build.gradle.kts...")
            version_parts = version.split(".")
            if len(version_parts) != 3:
                raise ValueError("Version must be in the format 'major.minor.patch' (e.g., '1.2.3').")

            version_major, version_minor, version_patch = version_parts

            with open(build_gradle_path, "r") as file:
                gradle_content = file.readlines()

            with open(build_gradle_path, "w") as file:
                for line in gradle_content:
                    if line.strip().startswith("private val versionMajor"):
                        line = "private val versionMajor = {}\n".format(version_major)
                    elif line.strip().startswith("private val versionMinor"):
                        line = "private val versionMinor = {}\n".format(version_minor)
                    elif line.strip().startswith("private val versionPatch"):
                        line = "private val versionPatch = {}\n".format(version_patch)
                    file.write(line)

            print("Version updated in build.gradle.kts: Major={}, Minor={}, Patch={}".format(
                version_major, version_minor, version_patch))

        # Build the Android plugin
        print("Building Android plugin in {} target...".format(target))
        subprocess.check_call(["./gradlew", gradle_task], cwd="Source/Android")

        # Move the AAR to the plugin directory
        aar_dir = "Source/Android/build/outputs/aar/"
        plugin_name = "AppLovin-MAX-Godot-Plugin.aar"
        rename("{}AppLovin-MAX-Godot-standalone-{}.aar".format(aar_dir, target.lower()), plugin_name)
        move(aar_dir + plugin_name, "android/plugins/AppLovin-MAX-Godot-Plugin/")

        print("Android plugin build in {} target completed successfully.".format(target))
    except Exception as e:
        print("Error during Android plugin {} build: {}".format(target), e)

# Clean up artifacts generated by previous builds or downloads.
def clean():
    print("Cleaning up old artifacts and builds...")
    
    # Remove the 'godot' folder if it exists
    if os.path.exists("godot"):
        print("Removing 'godot' folder...")
        shutil.rmtree("godot")
    
    # Remove any .tar.xz files
    for file in os.listdir("."):
        if file.endswith(".tar.xz"):
            print("Removing archive: {}...".format(file))
            os.remove(file)

    # Remove godot-lib artifacts
    godot_lib_files = glob.glob("godot-lib.*.aar")
    for godot_lib_file in godot_lib_files:
        print("Removing Godot Android library: {}...".format(godot_lib_file))
        os.remove(godot_lib_file)

    # Remove godot-lib from Source/Android/libs/
    android_libs_dir = "Source/Android/libs/"
    if os.path.exists(android_libs_dir):
        print("Cleaning up Godot Android libraries in {}...".format(android_libs_dir))
        for file in glob.glob(os.path.join(android_libs_dir, "godot-lib*.aar")):
            print("Removing {}".format(file))
            os.remove(file)

    # Remove artifacts in iOS build directory
    ios_build_dir = "Source/iOS/build"
    if os.path.exists(ios_build_dir):
        print("Cleaning up iOS build directory: {}...".format(ios_build_dir))
        shutil.rmtree(ios_build_dir)

    # Remove Pods
    subprocess.call(["pod", "deintegrate"], cwd="Source/iOS")
    
    print("Clean complete.")

### Plugin Development ###

# Generate the engine iOS headers for the iOS plugin to import
def generate_ios_headers():
    try:
        os.chdir("./godot")
        print("Running SCons to generate iOS headers...")
        subprocess.call(["scons", "platform=ios", "target=template_release"])
    except Exception as e:
        print("Error while generating iOS headers: {}".format(e))
    finally:
        os.chdir("..")

# Generate the AppLovinSDK dependency
def generate_pods():
    try:
        print("Generating AppLovinSDK dependency...")
        subprocess.call(["pod", "install"], cwd="Source/iOS")
    except Exception as e:
        print("Error while generating AppLovinSDK dependency: {}".format(e))

# Downloads the official Godot engine
def download_godot(version, stable=True):
    if not version:
        print("Error: Please provide the Godot version as an argument.")
        sys.exit(1)

    version_suffix = "-stable" if stable else ""

    godot_folder = "godot-{}{}".format(version, version_suffix)
    download_file = "{}.tar.xz".format(godot_folder)
    url = "https://github.com/godotengine/godot/releases/download/{}{}/{}".format(version, version_suffix, download_file)

    print("Downloading Godot version {} from {}...".format(version, url))
    urlretrieve(url, download_file)

    print("Extracting {}...".format(download_file))
    with tarfile.open(download_file, "r:xz") as tar:
        tar.extractall()

    if os.path.exists("godot"):
        print("Deleting existing 'godot' folder...")
        shutil.rmtree("godot")

    os.rename(godot_folder, "godot")
    os.remove(download_file)
    print("Download and extraction complete.")

# Download the Godot Android lib
def download_godot_android_lib(version, stable=True):
    if not version:
        print("Error: Please provide the Godot version as an argument.")
        sys.exit(1)

    try:
        version_suffix = "-stable" if stable else ""

        # Format the URL and output file name
        download_file = "godot-lib.{}{}.template_release.aar".format(version.replace("-", "."), version_suffix.replace("-", "."))
        url = "https://github.com/godotengine/godot/releases/download/{}{}/{}".format(
            version, version_suffix, download_file
        )

        # Download the file
        print("Downloading Godot Android library version {} from {}...".format(version, url))
        urlretrieve(url, download_file)

        print("Godot Android library downloaded successfully as {}".format(download_file))

        godot_android_lib_name = "godot-lib-{}{}.aar".format(version, version_suffix)
        rename(download_file, godot_android_lib_name)
        move(godot_android_lib_name, "Source/Android/libs")

    except Exception as e:
        raise Exception("Error downloading Godot Android library: {}".format(e))

### Utils ###

# Generate xcframework for iOS plugin
def generate_xcframework(target, version, output_dir):
    try:
        print("Starting XCFramework generation for target: {}, version: {}".format(target, version))

        # Ensure the destination directory exists
        if not os.path.exists(output_dir):
            print("Creating directory: {}".format(output_dir))
            os.makedirs(output_dir)

        # Define paths for static libraries and XCFramework
        scheme = "AppLovin-MAX-Godot-Plugin"
        workspace = "Source/iOS/AppLovin-MAX-Godot-Plugin.xcworkspace"
        product = "libAppLovinMAXGodotPlugin.a"
        device_library_path = os.path.join(output_dir, "{}-device.{}.xcarchive".format(scheme, target))
        simulator_library_path = os.path.join(output_dir, "{}-simulator.{}.xcarchive".format(scheme, target))
        xcframework_path = os.path.join(output_dir, "{}.{}.xcframework".format(scheme, target))

        # Build for ARM64 device
        print("Building for ARM64 device...")
        build_xcarchive(scheme, target, "iphoneos", device_library_path, workspace)

        # Build for ARM64 simulator
        print("Building for ARM64 simulator...")
        build_xcarchive(scheme, target, "iphonesimulator", simulator_library_path, workspace)

        # Create XCFramework
        print("Creating XCFramework at {}...".format(xcframework_path))
        subprocess.check_call([
            "xcodebuild", "-create-xcframework",
            "-library", os.path.join(device_library_path, "Products/usr/local/lib", product),
            "-library", os.path.join(simulator_library_path, "Products/usr/local/lib", product),
            "-output", xcframework_path
        ])

        print("XCFramework generated successfully at {}".format(xcframework_path))

    except subprocess.CalledProcessError as e:
        raise Exception("An error occurred while generating the XCFramework: {}".format(e))
    
def build_xcarchive(scheme, target, arch, archivePath, workspace):
    print("Starting xcode archive for scheme: {}, target: {}, arch: {}".format(scheme, target, arch))

    xcodebuild_command = [
        "xcodebuild",
        "archive",
        "-workspace", workspace,
        "-scheme", scheme,
        "-sdk", arch,
        "-configuration", target,
        "-archivePath", archivePath,
        "SKIP_INSTALL=NO"
    ]

    # Only append preprocessor definitions for debug builds
    if target.lower() == "debug":
        xcodebuild_command.append('GCC_PREPROCESSOR_DEFINITIONS="DEBUG_ENABLED=1"')

    subprocess.check_call(xcodebuild_command)
    
# Moves a file from the source path to the destination directory.
def move(source_path, destination_dir):
    try:
        # Check if the source file exists
        if not os.path.exists(source_path):
            raise Exception("Source file {} does not exist.".format(source_path))

        # Ensure the destination directory exists
        if not os.path.exists(destination_dir):
            print("Creating directory: {}".format(destination_dir))
            os.makedirs(destination_dir)

        # Extract the file name from the source path
        file_name = os.path.basename(source_path)

        # Construct the destination path
        destination_path = os.path.join(destination_dir, file_name)

        # Move the file
        print("Moving {} to {}...".format(file_name, destination_dir))
        shutil.move(source_path, destination_path)

        print("File successfully moved to {}.".format(destination_path))

    except Exception as e:
        raise Exception("Error moving file: {}".format(e))

# Rename file at path
def rename(source_path, new_name):
    try:
        # Get the directory of the source file
        directory = os.path.dirname(source_path)

        # Construct the new path
        new_path = os.path.join(directory, new_name)

        # Rename the file
        print("Renaming {} to {}...".format(source_path, new_path))
        os.rename(source_path, new_path)

        print("File successfully renamed to {}.".format(new_path))
        return new_path

    except Exception as e:
        raise Exception("Error renaming file: {}".format(e))

### Main Script Execution ###
def main():
    if len(sys.argv) < 2:
        show_help()
        sys.exit(1)

    command = sys.argv[1]

    try:
        if command in ("-h", "--help"):
            show_help()

        elif command == "clean":
            clean()

        elif command == "prepare_plugin_environment":
            if len(sys.argv) < 3:
                print("Error: 'prepare_plugin_environment' requires a Godot version as an argument.")
                sys.exit(1)
            prepare_plugin_environment(sys.argv[2])

        elif command == "build_ios":
            version = None
            debug = "--debug" in sys.argv

            # Parse optional version argument
            for arg in sys.argv[2:]:
                if arg.startswith("--version="):
                    version = arg.split("=")[1]

            build_ios(version=version, debug=debug)

        elif command == "build_android":
            version = None
            debug = "--debug" in sys.argv

            # Parse optional version argument
            for arg in sys.argv[2:]:
                if arg.startswith("--version="):
                    version = arg.split("=")[1]

            build_android(version=version, debug=debug)

        elif command == "download_godot":
            if len(sys.argv) < 3:
                print("Error: 'download_godot' requires a Godot version as an argument.")
                sys.exit(1)
            download_godot(sys.argv[2])

        elif command == "download_android_lib":
            if len(sys.argv) < 3:
                print("Error: 'download_android_lib' requires a Godot version as an argument.")
                sys.exit(1)
            download_godot_android_lib(sys.argv[2])

        elif command == "generate_ios_headers":
            generate_ios_headers()

        else:
            print("Unknown command: {}".format(command))
            show_help()
            sys.exit(1)

    except Exception as e:
        print("Error: {}".format(e))
        sys.exit(1)

if __name__ == "__main__":
    main()
